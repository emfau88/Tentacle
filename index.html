
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tentacle Wars</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: none; }
        html, body { width: 100%; height: 100%; background: #050508; overflow: hidden; font-family: -apple-system, sans-serif; position: fixed; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #ui { position: absolute; top: max(10px, env(safe-area-inset-top)); left: max(10px, env(safe-area-inset-left)); color: #fff; font-size: 14px; pointer-events: none; text-shadow: 0 0 10px rgba(0,255,100,0.5); z-index: 10; font-weight: 600; }
        #instructions { position: absolute; bottom: max(20px, env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.7); font-size: 13px; text-align: center; pointer-events: none; z-index: 10; background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 20px; white-space: nowrap; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 40px 30px; border-radius: 20px; border: 2px solid #00ff88; color: #fff; text-align: center; display: none; z-index: 20; min-width: 280px; }
        #gameOver h2 { color: #00ff88; margin-bottom: 15px; font-size: 28px; }
        #restartBtn { background: #00ff88; color: #000; border: none; padding: 15px 40px; border-radius: 25px; cursor: pointer; font-weight: bold; font-size: 16px; pointer-events: all; }
        #restartBtn:active { transform: scale(0.95); background: #00cc6a; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui"><div>üü¢ <span id="cellCount">0</span></div><div>‚ö° <span id="unitCount">0</span></div></div>
    <div id="instructions">üëÜ Ziehe von deinen Zellen ‚Ä¢ ‚úÇÔ∏è Wische zum Schneiden</div>
    <div id="gameOver"><h2 id="gameOverText">Sieg!</h2><p id="gameOverSub"></p><button id="restartBtn" onclick="game.restart()">Neues Spiel</button></div>

<script>
const CONSTANTS = {
    CELL_RADIUS_MIN: 26, PRODUCTION_RATE: 1.0, CAPACITY_BASE: 50, THROUGHPUT: 4, PACKET_SIZE: 4, 
    TRAVEL_SPEED: 80, MAX_TENTACLES_PER_CELL: 3, CUT_THRESHOLD: 15,
    COLORS: { PLAYER: '#00ff88', ENEMY: '#ff3366', NEUTRAL: '#8899aa', PLAYER_GLOW: 'rgba(0, 255, 136, 0.4)', ENEMY_GLOW: 'rgba(255, 51, 102, 0.4)', NEUTRAL_GLOW: 'rgba(136, 153, 170, 0.3)' }
};
const dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);
const lerp = (a, b, t) => a + (b - a) * t;
const bezier = (p0, p1, p2, t) => ({ x: (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x, y: (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y });

class ParticleSystem {
    constructor() { this.particles = []; }
    explode(x, y, color, count = 15) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
            const speed = 2 + Math.random() * 4;
            this.particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 1.0, decay: 0.02 + Math.random() * 0.02, color, size: 3 + Math.random() * 4 });
        }
    }
    update() { this.particles = this.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98; p.life -= p.decay; return p.life > 0; }); }
    draw(ctx) { this.particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1; }
}

class Packet {
    constructor(tentacle, amount, owner) { this.tentacle = tentacle; this.amount = amount; this.owner = owner; this.t = 0; this.speed = CONSTANTS.TRAVEL_SPEED / tentacle.length; this.active = true; }
    update(dt) { if (!this.active) return; this.t += this.speed * dt; if (this.t >= 1) { this.t = 1; this.arrive(); } }
    arrive() { this.active = false; const target = this.tentacle.targetCell; if (this.owner === target.owner) target.units = Math.min(target.capacity, target.units + this.amount); else { target.units -= this.amount; if (target.units <= 0) { const oldOwner = target.owner; target.owner = this.owner; target.units = Math.abs(target.units); target.units = Math.min(target.capacity, Math.max(10, target.units)); const color = this.owner === 'player' ? CONSTANTS.COLORS.PLAYER : CONSTANTS.COLORS.ENEMY; game.particles.explode(target.x, target.y, color, 20); game.tentacles = game.tentacles.filter(t => { if (t.targetCell === target && t.owner !== this.owner) { t.sever(); return false; } return true; }); } } }
    getPosition() { return this.tentacle.getPointAt(this.t); }
}

class Tentacle {
    constructor(sourceCell, targetCell) { this.sourceCell = sourceCell; this.targetCell = targetCell; this.owner = sourceCell.owner; this.state = 'active'; this.packets = []; this.flowAccumulator = 0; this.length = dist(sourceCell.x, sourceCell.y, targetCell.x, targetCell.y); this.throughput = CONSTANTS.THROUGHPUT; this.wavePhase = Math.random() * Math.PI * 2; this.controlPoint = this.calculateControlPoint(); }
    calculateControlPoint() { const midX = (this.sourceCell.x + this.targetCell.x) / 2, midY = (this.sourceCell.y + this.targetCell.y) / 2; const perpX = -(this.targetCell.y - this.sourceCell.y), perpY = (this.targetCell.x - this.sourceCell.x); const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1; const offset = (Math.random() - 0.5) * this.length * 0.4; return { x: midX + (perpX / len) * offset, y: midY + (perpY / len) * offset }; }
    getPointAt(t) { const wave = Math.sin(t * Math.PI * 4 + this.wavePhase + Date.now() / 500) * 3; const base = bezier({x: this.sourceCell.x, y: this.sourceCell.y}, this.controlPoint, {x: this.targetCell.x, y: this.targetCell.y}, t); const dx = this.targetCell.x - this.sourceCell.x, dy = this.targetCell.y - this.sourceCell.y; const len = Math.sqrt(dx * dx + dy * dy) || 1; return { x: base.x + (-dy / len) * wave, y: base.y + (dx / len) * wave }; }
    update(dt) { if (this.state === 'severed') return; if (this.sourceCell.units > 0 && this.sourceCell.owner === this.owner) { this.flowAccumulator += this.throughput * dt; while (this.flowAccumulator >= CONSTANTS.PACKET_SIZE && this.sourceCell.units >= CONSTANTS.PACKET_SIZE) { this.packets.push(new Packet(this, CONSTANTS.PACKET_SIZE, this.owner)); this.sourceCell.units -= CONSTANTS.PACKET_SIZE; this.flowAccumulator -= CONSTANTS.PACKET_SIZE; } } this.packets = this.packets.filter(p => p.active); this.packets.forEach(p => p.update(dt)); if (this.sourceCell.owner !== this.owner) this.sever(); }
    sever(cutT = null) { this.state = 'severed'; if (cutT !== null) { let remaining = 0; this.packets.forEach(p => { if (p.t >= cutT) { remaining += p.amount; p.active = false; } }); if (remaining > 0) { const target = this.targetCell; if (this.owner === target.owner) target.units = Math.min(target.capacity, target.units + remaining); else { target.units -= remaining; if (target.units <= 0) { target.owner = this.owner; target.units = Math.abs(target.units); target.units = Math.min(target.capacity, Math.max(10, target.units)); } } } } this.packets = []; }
    draw(ctx) { if (this.state === 'severed') return; const color = this.owner === 'player' ? CONSTANTS.COLORS.PLAYER : this.owner === 'enemy' ? CONSTANTS.COLORS.ENEMY : CONSTANTS.COLORS.NEUTRAL; const glowColor = this.owner === 'player' ? CONSTANTS.COLORS.PLAYER_GLOW : this.owner === 'enemy' ? CONSTANTS.COLORS.ENEMY_GLOW : CONSTANTS.COLORS.NEUTRAL_GLOW; ctx.beginPath(); for (let i = 0; i <= 50; i++) { const pos = this.getPointAt(i / 50); if (i === 0) ctx.moveTo(pos.x, pos.y); else ctx.lineTo(pos.x, pos.y); } ctx.shadowColor = color; ctx.shadowBlur = 15; ctx.strokeStyle = glowColor; ctx.lineWidth = 12; ctx.lineCap = 'round'; ctx.stroke(); ctx.shadowBlur = 0; ctx.strokeStyle = color; ctx.lineWidth = 5; ctx.stroke(); ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 2; ctx.stroke(); const time = Date.now() / 1000; for (let i = 0; i < 3; i++) { const pulsePos = ((time * 0.5 + i * 0.33) % 1); const pos = this.getPointAt(pulsePos); ctx.beginPath(); ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.fill(); } this.packets.forEach(p => { const pos = p.getPosition(); ctx.beginPath(); ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.shadowColor = color; ctx.shadowBlur = 10; ctx.fill(); ctx.shadowBlur = 0; ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke(); }); }
    containsPoint(x, y, threshold = 30) { let closestDist = Infinity; for (let i = 0; i <= 20; i++) { const pos = this.getPointAt(i / 20); const d = dist(x, y, pos.x, pos.y); if (d < closestDist) closestDist = d; } return closestDist < threshold ? 0.5 : -1; }
}

class Cell {
    constructor(x, y, owner = 'neutral', size = 1) { this.x = x; this.y = y; this.owner = owner; this.radius = CONSTANTS.CELL_RADIUS_MIN + (size * 7); this.capacity = CONSTANTS.CAPACITY_BASE + (size * 20); this.units = owner === 'neutral' ? 15 + Math.random() * 15 : 10; this.productionRate = CONSTANTS.PRODUCTION_RATE; this.maxTentacles = CONSTANTS.MAX_TENTACLES_PER_CELL; this.pulsePhase = Math.random() * Math.PI * 2; this.veinOffset = Math.random() * 100; }
    update(dt) { if (this.owner !== 'neutral') this.units = Math.min(this.capacity, this.units + this.productionRate * dt); }
    draw(ctx) { const time = Date.now() / 1000, pulse = Math.sin(time * 2 + this.pulsePhase) * 2; const color = this.owner === 'player' ? CONSTANTS.COLORS.PLAYER : this.owner === 'enemy' ? CONSTANTS.COLORS.ENEMY : CONSTANTS.COLORS.NEUTRAL; const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius + 20 + pulse); gradient.addColorStop(0, color + '60'); gradient.addColorStop(0.5, color + '30'); gradient.addColorStop(1, 'transparent'); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 25, 0, Math.PI * 2); ctx.fill(); for (let i = 3; i >= 1; i--) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + i * 2, 0, Math.PI * 2); ctx.strokeStyle = color + (20 + i * 10).toString(16); ctx.lineWidth = 1; ctx.stroke(); } ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = '#0a0a0f'; ctx.fill(); ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2); const fillRatio = this.units / this.capacity; ctx.fillStyle = color + Math.floor(fillRatio * 160).toString(16).padStart(2, '0'); ctx.fill(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2); ctx.fillStyle = color; ctx.globalAlpha = 0.3 + fillRatio * 0.5; ctx.fill(); ctx.globalAlpha = 1; ctx.fillStyle = '#fff'; ctx.font = `bold ${Math.max(13, this.radius * 0.38)}px -apple-system, sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.9)'; ctx.shadowBlur = 4; ctx.fillText(Math.floor(this.units), this.x, this.y); ctx.shadowBlur = 0; ctx.strokeStyle = color + '40'; ctx.lineWidth = 1; for (let i = 0; i < 3; i++) { const angle = (i / 3) * Math.PI * 2 + time * 0.5 + this.veinOffset; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.8, angle, angle + 1); ctx.stroke(); } }
    containsPoint(x, y) { return dist(x, y, this.x, this.y) < this.radius + 5; }
}

class EnemyAI {
    constructor() { this.thinkTimer = 0; this.thinkInterval = 4.0; }
    update(dt) { this.thinkTimer += dt; if (this.thinkTimer < this.thinkInterval) return; this.thinkTimer = 0; const enemyCells = game.cells.filter(c => c.owner === 'enemy'), playerCells = game.cells.filter(c => c.owner === 'player'), neutralCells = game.cells.filter(c => c.owner === 'neutral'); const activeCells = enemyCells.filter(() => Math.random() > 0.5); activeCells.forEach(cell => { const outgoing = game.tentacles.filter(t => t.sourceCell === cell && t.state === 'active'); if (outgoing.length >= cell.maxTentacles) return; if (cell.units < 35) return; let target = null, bestScore = -1; neutralCells.forEach(tc => { const d = dist(cell.x, cell.y, tc.x, tc.y); if (d > 400) return; const s = (50 - tc.units) / (d / 100 + 1); if (s > bestScore) { bestScore = s; target = tc; } }); if (!target && cell.units > 50) { playerCells.forEach(tc => { const d = dist(cell.x, cell.y, tc.x, tc.y); if (d > 350) return; if (tc.units < cell.units * 0.5) { const s = (100 - tc.units) / (d / 100 + 1); if (s > bestScore) { bestScore = s; target = tc; } } }); } if (target && !game.tentacles.some(t => t.sourceCell === cell && t.targetCell === target && t.state === 'active')) game.createTentacle(cell, target); }); }
}

class InputHandler {
    constructor(canvas) { this.canvas = canvas; this.isDragging = false; this.dragStartCell = null; this.dragCurrentPos = {x: 0, y: 0}; this.swipeStart = null; this.swipePoints = []; this.touchId = null; this.showRange = null; canvas.addEventListener('touchstart', this.onTouchStart.bind(this), {passive: false}); canvas.addEventListener('touchmove', this.onTouchMove.bind(this), {passive: false}); canvas.addEventListener('touchend', this.onTouchEnd.bind(this), {passive: false}); canvas.addEventListener('touchcancel', this.onTouchEnd.bind(this), {passive: false}); canvas.addEventListener('mousedown', this.onMouseDown.bind(this)); canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); canvas.addEventListener('mouseup', this.onMouseUp.bind(this)); }
    getPointerPos(e) { const rect = this.canvas.getBoundingClientRect(); let clientX, clientY; if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; } else { clientX = e.clientX; clientY = e.clientY; } return { x: (clientX - rect.left) * (this.canvas.width / rect.width), y: (clientY - rect.top) * (this.canvas.height / rect.height) }; }
    onTouchStart(e) { e.preventDefault(); if (this.touchId !== null) return; const touch = e.touches[0]; this.touchId = touch.identifier; const pos = this.getPointerPos(e); this.handleStart(pos); }
    onTouchMove(e) { e.preventDefault(); if (this.touchId === null) return; const touch = Array.from(e.touches).find(t => t.identifier === this.touchId); if (!touch) return; const pos = this.getPointerPos(e); this.handleMove(pos); }
    onTouchEnd(e) { e.preventDefault(); if (this.touchId === null) return; const touch = Array.from(e.changedTouches).find(t => t.identifier === this.touchId); if (!touch) return; this.touchId = null; const pos = this.getPointerPos(e); this.handleEnd(pos); }
    onMouseDown(e) { const pos = this.getPointerPos(e); this.handleStart(pos); }
    onMouseMove(e) { const pos = this.getPointerPos(e); this.handleMove(pos); }
    onMouseUp(e) { const pos = this.getPointerPos(e); this.handleEnd(pos); }
    handleStart(pos) { const cell = game.getCellAt(pos.x, pos.y); if (cell && cell.owner === 'player') { this.isDragging = true; this.dragStartCell = cell; this.dragCurrentPos = pos; this.swipeStart = null; this.showRange = cell; } else { this.isDragging = false; this.dragStartCell = null; this.swipeStart = pos; this.swipePoints = [pos]; this.showRange = null; } }
    handleMove(pos) { if (this.isDragging) this.dragCurrentPos = pos; else if (this.swipeStart) { this.swipePoints.push(pos); if (this.swipePoints.length > 8) this.swipePoints.shift(); } }
    handleEnd(pos) { this.showRange = null; if (this.isDragging && this.dragStartCell) { const targetCell = game.getCellAt(pos.x, pos.y); if (targetCell && targetCell !== this.dragStartCell && !game.tentacles.some(t => t.sourceCell === this.dragStartCell && t.targetCell === targetCell && t.state === 'active')) game.createTentacle(this.dragStartCell, targetCell); this.isDragging = false; this.dragStartCell = null; } else if (this.swipeStart) { if (dist(this.swipeStart.x, this.swipeStart.y, pos.x, pos.y) > CONSTANTS.CUT_THRESHOLD) this.processCut(); this.swipeStart = null; this.swipePoints = []; } }
    processCut() { if (this.swipePoints.length < 2) return; const start = this.swipePoints[0], end = this.swipePoints[this.swipePoints.length - 1]; const midX = (start.x + end.x) / 2, midY = (start.y + end.y) / 2; game.tentacles.forEach(tentacle => { if (tentacle.state !== 'active') return; const cutT = tentacle.containsPoint(midX, midY, 35); if (cutT >= 0) { tentacle.sever(cutT); setTimeout(() => { game.tentacles = game.tentacles.filter(t => t !== tentacle); }, 150); } }); }
    draw(ctx) { if (this.showRange) { ctx.beginPath(); ctx.arc(this.showRange.x, this.showRange.y, 150, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(0, 255, 136, 0.2)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); } if (this.isDragging && this.dragStartCell) { ctx.beginPath(); ctx.moveTo(this.dragStartCell.x, this.dragStartCell.y); ctx.lineTo(this.dragCurrentPos.x, this.dragCurrentPos.y); ctx.strokeStyle = 'rgba(0, 255, 136, 0.8)'; ctx.lineWidth = 4; ctx.setLineDash([8, 8]); ctx.stroke(); ctx.setLineDash([]); const targetCell = game.getCellAt(this.dragCurrentPos.x, this.dragCurrentPos.y); if (targetCell && targetCell !== this.dragStartCell) { ctx.beginPath(); ctx.arc(targetCell.x, targetCell.y, targetCell.radius + 8, 0, Math.PI * 2); ctx.strokeStyle = CONSTANTS.COLORS.PLAYER; ctx.lineWidth = 3; ctx.stroke(); const ratio = this.dragStartCell.units / (targetCell.units + 1); const color = ratio > 1.5 ? '#00ff88' : ratio > 1 ? '#ffff00' : '#ff6666'; ctx.fillStyle = color; ctx.font = 'bold 14px sans-serif'; ctx.fillText(ratio.toFixed(1) + 'x', targetCell.x, targetCell.y - targetCell.radius - 15); } } if (this.swipePoints.length > 1) { ctx.beginPath(); ctx.moveTo(this.swipePoints[0].x, this.swipePoints[0].y); for (let i = 1; i < this.swipePoints.length; i++) ctx.lineTo(this.swipePoints[i].x, this.swipePoints[i].y); ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)'; ctx.lineWidth = 5; ctx.lineCap = 'round'; ctx.stroke(); } }
}

class Game {
    constructor() { this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d'); this.cells = []; this.tentacles = []; this.input = new InputHandler(this.canvas); this.ai = new EnemyAI(); this.particles = new ParticleSystem(); this.lastTime = 0; this.gameState = 'playing'; this.bgVeins = []; this.resize(); this.generateBackground(); setTimeout(() => { this.resize(); this.setupLevel(); }, 100); this.loop(); window.addEventListener('resize', () => { this.resize(); this.generateBackground(); }); document.addEventListener('gesturestart', (e) => e.preventDefault()); document.addEventListener('gesturechange', (e) => e.preventDefault()); document.addEventListener('gestureend', (e) => e.preventDefault()); }
    generateBackground() { this.bgVeins = []; const count = Math.floor((this.canvas.width * this.canvas.height) / 40000); for (let i = 0; i < count; i++) { this.bgVeins.push({ x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height, radius: 50 + Math.random() * 100, angle: Math.random() * Math.PI * 2 }); } }
    resize() { const vh = window.innerHeight, vw = window.innerWidth; this.canvas.width = vw; this.canvas.height = vh; this.canvas.style.width = vw + 'px'; this.canvas.style.height = vh + 'px'; }
    setupLevel() { this.cells = []; this.tentacles = []; this.gameState = 'playing'; document.getElementById('gameOver').style.display = 'none'; const w = this.canvas.width, h = this.canvas.height, cx = w / 2, cy = h / 2, isPortrait = h > w, minDim = Math.min(w, h); if (isPortrait) { const marginY = h * 0.18, marginX = w * 0.28, gapY = (h - 2 * marginY) / 3; this.cells.push(new Cell(cx, h - marginY, 'player', 1.3)); this.cells.push(new Cell(marginX, h - marginY - gapY * 0.8, 'player', 0.9)); this.cells.push(new Cell(w - marginX, h - marginY - gapY * 0.8, 'player', 0.9)); this.cells.push(new Cell(cx, marginY, 'enemy', 1.3)); this.cells.push(new Cell(marginX, marginY + gapY * 0.8, 'enemy', 0.9)); this.cells.push(new Cell(w - marginX, marginY + gapY * 0.8, 'enemy', 0.9)); this.cells.push(new Cell(cx, cy, 'neutral', 1.0)); this.cells.push(new Cell(cx - gapY * 0.5, cy - gapY * 0.25, 'neutral', 0.7)); this.cells.push(new Cell(cx + gapY * 0.5, cy - gapY * 0.25, 'neutral', 0.7)); } else { const marginX = w * 0.15, marginY = h * 0.22, gapX = (w - 2 * marginX) / 3; this.cells.push(new Cell(marginX, cy, 'player', 1.3)); this.cells.push(new Cell(marginX + gapX * 0.6, marginY, 'player', 0.9)); this.cells.push(new Cell(marginX + gapX * 0.6, h - marginY, 'player', 0.9)); this.cells.push(new Cell(w - marginX, cy, 'enemy', 1.3)); this.cells.push(new Cell(w - marginX - gapX * 0.6, marginY, 'enemy', 0.9)); this.cells.push(new Cell(w - marginX - gapX * 0.6, h - marginY, 'enemy', 0.9)); this.cells.push(new Cell(cx, cy - gapX * 0.25, 'neutral', 1.0)); this.cells.push(new Cell(cx, cy + gapX * 0.25, 'neutral', 1.0)); this.cells.push(new Cell(cx - gapX * 0.35, cy, 'neutral', 0.7)); this.cells.push(new Cell(cx + gapX * 0.35, cy, 'neutral', 0.7)); } const baseRadius = Math.min(26, minDim * 0.085); this.cells.forEach(cell => { cell.radius = baseRadius + (cell.capacity - CONSTANTS.CAPACITY_BASE) / 12; }); }
    createTentacle(source, target) { const outgoing = this.tentacles.filter(t => t.sourceCell === source && t.state === 'active'); if (outgoing.length >= source.maxTentacles) { const oldest = outgoing[0]; oldest.sever(); setTimeout(() => { this.tentacles = this.tentacles.filter(t => t !== oldest); }, 200); } this.tentacles.push(new Tentacle(source, target)); }
    getCellAt(x, y) { return this.cells.find(c => c.containsPoint(x, y)); }
    update(dt) { if (this.gameState !== 'playing') return; this.cells.forEach(c => c.update(dt)); this.tentacles.forEach(t => t.update(dt)); this.tentacles = this.tentacles.filter(t => t.state !== 'severed'); this.ai.update(dt); this.particles.update(); const playerCells = this.cells.filter(c => c.owner === 'player').length, enemyCells = this.cells.filter(c => c.owner === 'enemy').length; if (enemyCells === 0 && playerCells > 0) { this.gameState = 'won'; this.showGameOver(true); } else if (playerCells === 0) { this.gameState = 'lost'; this.showGameOver(false); } document.getElementById('cellCount').textContent = playerCells; document.getElementById('unitCount').textContent = Math.floor(this.cells.filter(c => c.owner === 'player').reduce((sum, c) => sum + c.units, 0)); }
    showGameOver(won) { const go = document.getElementById('gameOver'), title = document.getElementById('gameOverText'), sub = document.getElementById('gameOverSub'); go.style.display = 'block'; if (won) { title.textContent = 'Sieg!'; title.style.color = '#00ff88'; sub.textContent = 'Alle Gegner besiegt!'; } else { title.textContent = 'Niederlage'; title.style.color = '#ff3366'; sub.textContent = 'Deine Zellen wurden zerst√∂rt.'; } }
    restart() { this.setupLevel(); }
    draw() { const gradient = this.ctx.createRadialGradient(this.canvas.width/2, this.canvas.height/2, 0, this.canvas.width/2, this.canvas.height/2, Math.max(this.canvas.width, this.canvas.height)); gradient.addColorStop(0, '#1a1a2e'); gradient.addColorStop(0.5, '#0d0d15'); gradient.addColorStop(1, '#050508'); this.ctx.fillStyle = gradient; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.strokeStyle = 'rgba(40, 30, 60, 0.3)'; this.ctx.lineWidth = 2; this.bgVeins.forEach(vein => { this.ctx.beginPath(); this.ctx.arc(vein.x, vein.y, vein.radius, vein.angle, vein.angle + 2); this.ctx.stroke(); }); this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)'; this.ctx.lineWidth = 1; for (let x = 0; x < this.canvas.width; x += 50) { this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, this.canvas.height); this.ctx.stroke(); } for (let y = 0; y < this.canvas.height; y += 50) { this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(this.canvas.width, y); this.ctx.stroke(); } this.tentacles.forEach(t => t.draw(this.ctx)); this.cells.forEach(c => c.draw(this.ctx)); this.particles.draw(this.ctx); this.input.draw(this.ctx); }
    loop() { const now = performance.now(); const dt = Math.min((now - this.lastTime) / 1000, 0.1); this.lastTime = now; this.update(dt); this.draw(); requestAnimationFrame(() => this.loop()); }
}
const game = new Game();
</script>
</body>
</html>
